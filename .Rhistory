setwd("~/")
?indent
??indent
#Dates and Times
?Date
#Times
?POSIXct
?POSIXlt
#Dates stored as # of days since 1970-01-01
#Time is # of seconds since 1970-01-01
as.Date("1970-01-01")
#Dates stored as # of days since 1970-01-01
#Time is # of seconds since 1970-01-01
x<- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
unclass(as.Date("2020-04-29"))
Sys.time()
x<-Sys.time()
x
p<-as.POSIXlt(x)
names(unclass(p))
p$sec
unclass(x)
#x is already in POSITct, unclass to get # of seconds
#strptime function in case dates are written different format
datestring<-c("January 10, 2012 10:40","December 9, 2011 9:10")
x<-strptime(datestring,"%B %d, %Y %H:%M")
x
class(x)
?strptime
#Date and Time Operations
x <- as.Date("2012-01-01")
y <- strp.time("9 Jan 2011 11:34:21","%d %b %Y %H:%M:%S")
y <- strptime("9 Jan 2011 11:34:21","%d %b %Y %H:%M:%S")
x-y
x<-as.POSIXlt(x)
x-y
#Takes into account leap years and time zones
x<-as.Date("2012-03-01");y<-as.Date("2012-02-28")
x-y
x<-as.POSIXct("2012-10-25 01:00:00")
y<-as.POSIXct("2012-10-25 06:00:00",tz="GMT")
x-y
?tz
y-x
library(swirl)
swirl()
Sys.Date()
mean(c(2,4,5))
x
boring_function()
boring_function()
boring_function <- function(x) {
x
}
boring_function()
boring_function(1)
submit()
boring_function('My first function')
boring_function('My first function!')
boring_function()
boring_function
submit()
my_mean(c(4,5,10))
submit()
remainder <- function(num, divisor=2) {
remainder(num,divisor)
# Remember: the last expression evaluated will be returned!
}
submit()
submit()
remainder(5)
remainder(11,5)
remainder(divisor=11,num=2)
remainder(divisor=11,num=5)
remainder(4,div=2)
args(remainder)
submit()
evaluate(sd,c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1},6)
evaluate(function(x)[1],c(8, 4, 0))
evaluate(function(x ,c(8, 4, 0)[1])
evaluate(function(x),c(8, 4, 0))
evaluate(function(x),c(8, 4, 0))
source('C:/Users/egarcia/AppData/Local/Temp/RtmpegHOsV/evaluate.R', echo=TRUE)
evaluate(function(x){[1]},c(8, 4, 0))
evaluate(function(x){x[1]},c(8, 4, 0))
evaluate(function(x){x[length(x)]},c(8,4,0))
?paste
paste("Programming","is","fun!")
submit()
telegram("Fuck you")
telegram()
telegram("ad libs")
submit()
place <- args [["..."]]
adjective <- args[["adjective"]]
submit()
# Do your argument unpacking here!
list(place,adjective)
submit()
submit()
submit()
submit()
submit()
submit()
mad_libs("Orlando, FL","concerned","coronavirus")
paste(a,%p%,b)
SUBMIT()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
'I' %p% 'love' %p% 'R!'
rm(list=ls())
## 1.1.3 Vectorized Arithmetic
weight <- c(60,72,57,90,95,72)
#can do vector calculations if same length
height <- c(1.75,1.80,1.65,1.90,1.74,1.91)
#mean, stdev
sum(weight)
bmi <- weight/height^2
#mean, stdev
sum(weight)
sum(weight)/length(weight)
xbar <- sum(weight)/length(weight)
weight - xbar
(weight - xbar)^2
sdev <- sqrt(sum((weight - xbar)^2)/(length(weight) - 1))
#but that shit's in there already, soooo
mean(weight)
sd(weight)
## use t-test to assume an average for BMI
?t.test
t.test(bmi, mu=22.5) ## mu defaults to 0 if not given
plot(height,weight)  ##makes scatterplot
hh <- c(1.65,1.70,1.75,1.80,1.85,1.90)
lines(hh,22.5 * hh^2) ##BMI test plot, superimposed
#logical vectors
c(T,T,F,T)
bmi<25
c("Huey","Dewey","Louie") #double quotes ok
#concatenate to get rid of quote
cat(c("Huey","Dewey","Louie"))
?rep
?seq
# c - concatenate
x <- c(1,2,3)
y <- c(10,20)
c(x,y,5)
#can name each element if you want
x <- c(red="Huey",blue="Dewey",green="Louie")
x
names(x)
#vectors have same type; concat converts to least restrictive
c(FALSE,3) #0 3
C(pi,"abc") #"pi as a string" "abc
C(pi,"abc")
C(pi,'abc') #"pi as a string" "abc
c(pi,'abc') #"pi as a string" "abc
c(FALSE,'abc')
seq(4,9)
#up by 2
seq(4,10,2)
#good vector for graphics, setting x & y axis and shit
hhs <- seq(1.65,1.90,.05)
#sequence is same as colon
4:9
4:10:2
oops <- c(7,9,13)
# second argument can be vector or single number (what it do?)
rep(oops,3)
#7  9 13  7  9 13  7  9 13
rep(oops,1:3)
#useful for group codes (10 men, 15 women, etc)
rep(1:2,c(10,15))
#Special Case: equal replications of each value
rep(1:2,each=10)
x <- 1:12
dim(x) <- c(3,4)
x
matrix(1:12,nrow=3,byrow=T)
#rownames, colnames, t (transpose)
x <- matrix(1:12,nrow=3,byrow=T)
rownames(x) <- LETTERS[1:3]
x
t(x)
cbind(A=1:4,B=5:8,C=9:12)
rbind(A=1:4,B=5:8,C=9:12)
pain <- c(0,3,2,2,1)
fpain <- factor(pain,levels=0:3)
levels(fpain) <- c("none","mild","medium","severe")
fpain <- factor(pain,levels=0:3) #categorical variable (factor)
fpain
levels(fpain) <- c("none","mild","medium","severe") #description
fpain
as.numeric(fpain)
levels(fpain)
intake.pre <- c(5260,5470,5640,6180,6390,
+ 6515,6805,7515,7515,8230,8770)
intake.post <- c(3910,4220,3885,5160,5645,
+ 4680,5265,5975,6790,6900,7335)
#combine vectors into a list
mylist <- list(before=intake.pre,after=intake.post)
mylist
mylist$before
d <- data.frame(intake.pre,intake.post)
d
d$intake.pre
intake.pre[5]
#you can also make it left hand of assignment to modify
intake.pre[5] <- 6390
#index several things with vectors
intake.pre[c(3,5,7)]
#can store vector into a variable and it still works
v <- c(3,5,7)
intake.pre[v]
#index a sequence
intake.pre[1:5]
#exclusion with - sign
intake.pre[-c(3,5,7)]
intake.post(intake.pre>7000)
intake.post(intake.pre > 7000)
intake.post[intake.pre > 7000]
intake.post[intake.pre > 7000 & intake.pre <= 8000]
intake.pre > 7000 & intake.pre <= 8000
[1] 5975 6790
d <- data.frame(intake.pre,intake.post)
d[5,1]
# [1] 6390
d[5,]
d[2]
d[d$intake.pre>7000]
d[d$intake.pre>7000,] #prove you weren't paying attention lol
#divide what just happened into steps
sel <- d$intake.pre>7000
sel
d[sel,]
# looking at first few cases with indexing
d[1:2,]
#there's a function for that called head that gives first six
head(d)
tail(d) #also tail for last 6
lapply(thuesen,mean,na.rm=T)
#replicate: count and expression to evaluate?
replicate(10,mean(rexp(20)))
?rexp
m <- matrix(rnorm(12),4)
m
?rnorm
?rexp
intake <- data.frame(intake.pre,intake.post)
intake <- data.frame(pre=intake.pre,post=intake.post)
intake$post
#  [1] 3910 4220 3885 5160 5645 4680 5265 5975 6790 6900 7335
sort(intake$post)
#sort series of variables according to another variable
order(intake$post)
o <- order(intake$post)
intake$post[o]
# [1] 3885 3910 4220 4680 5160 5265 5645 5975 6790 6900 7335
intake$pre[o]
#can sort whole data frame too
intake.sorted <- intake[o,]
intake.sorted
ls()
rm(height,weight)
rm(list=ls()) #clear that whole shit
save.image()
?d
str(rnorm)
str(pnorm) #
str(qnorm)
str(dnorm)
## how to do the shit
x <- rnorm(10)
x <- rnorm(10,20,2)
summary(x)
##set the seed for rng (appearance of randomness, consistent)
set.seed(1)
rnorm(5)
## [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
## should be same as his
rnorm(5)
## [1] -0.8204684  0.4874291  0.7383247  0.5757814 -0.3053884
## different, but same same?
get.seed()
set.seed(1)
rnorm(5)
## [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
set.seed(2)
rnorm(5)
set.seed(1)
## [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
## should be same as his
rnorm(5)
rnorm(5)
rpois(10,1)
str(rpois)
str(dpois)
str(ppois)
str(qpois)
## [1] 3 0 1 0 0 1 0 1 2 0
rpois(10,2)
rpois(10,20)
## mean = rate (more or less)
pp <- rpois(10,20)
str(pp)
summary(pp)
## Cumulative Distribution
ppois(2,2)
ppois(4,2)
## Cumulative Distribution
ppois(2,2) ## Pr(x <= 2)
ppois(4,2) ## Pr(x <= 4)
ppois(6,2) ## Pr(x <= 6)
pnorm(12,10,2)
pnorm(12,10,1)
pnorm(12,10,4)
setwd('~/Github/R2D2')
## Simulating a Linear Model
set.seed(20)
x <- rnorm(100)
e <- rnorm(100,0,2)
y <- 0.5 + 2 * x + e
summary(y)
plot(x,y)
## Example 2
set.seed(10)
x <- rbinom(100,1,0.5)
e <- rnorm(100,0,2)
y <- 0.5 + 2 * x + e
summary(y)
plot(x,y)
## Example 3 -- Poisson
set.seed(1)
x <- rnorm(100)
log.mu <- 0.5 + 0.3 * x
y <- rpois(100,exp(log.mu))
summary(y)
plot(x,y)
rm(list=ls())
set.seed(1)
sample(1:10,4)
?sample
sample(1:10,4)
sample(letters,5)
sample(1:10)
sample(1:10)
sample(1:10,replace = TRUE)
library(swirl)
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
plants
names(plants)
head(plants)
head(plants)
head(plants,10)
tail(plants,15)
summary(plants)
plants$Active_Growth_Period
table(plants$Active_Growth_Period)
str(plants)
swirl()
?sample
sample(1:6,4,replace=TRUE)
sample(1:6,4,replace=TRUE)
sample(1:20,10)
LETTERS
sample(LETTERS)
flips <- sample(c(0,1),100,replace=TRUE,prob=c(0.3,0.7))
flips
sum(flips)
?rbinom
rbinom(1,size=100,prob=0.7)
rbinom(100,size=1,prob=0.7)
flips2 <- rbinom(n=100,size=1,prob=0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10,mean=100,sd=25)
?rpois
rpois(5,mean=10)
rpois(5,10)
replicate(100,rpois(5,10)) #100 groups of them
my_pois <- replicate(100, rpois(5,10))
my_pois
colMeans(rpois)
colMeans(my_pois)
cm <- colMeans(my_pois)
hist(cm)
data(cars)
?cars
head(cars)
plot(cars)
?plot()
?plot
plot(x = cars$speed, y = cars$dist)
plot(cars$dist,cars$speed)
plot(Speed = cars$speed, Distance = cars$dist)
plot(cars$speed,cars$dist)
plot(x=cars$speed,y=cars$dist,xlab="Speed")
plot(x=cars$speed,y=cars$dist,xlab="Speed",ylab="Stopping Distance")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance")
plot(x=cars$speed,y=cars$dist,xlab="Speed",ylab="Stopping Distance")
plot(x=cars$speed,y=cars$dist,xlab="Speed",ylab="Stopping Distance", main = "My Plot")
plot(cars,main= "My Plot")
plot(cars, sub = "My Plot Subtitle")
plot(cars,col=2)
plot(cars,xlim=c(10,15))
plot(cars,pch=2)
#boxplots
data(mtcars)
play()
dim(mtcars)
colnames(mtcars)
rownames(mtcars)
head(mtcars)
tail(mtcars)
?mtcars
mtcars[,10]
mtcars$cyl=8
mt8 <- mtcars$cyl =8
mtcars$cyl
wtf
data("mtcars")
data(mtcars)
mtcars$cyl
mtcars[6]
mtcars[8]
mtcars[mtcars$cyl]
mtcars$cyl
colnames(mtcars)
mtcars[2]
testplot <- plot(x=mtcars$disp,y=mtcars$cyl,xlab="Displacement",ylab="Number of Cylinders")
testplot2 <- plot(x=mtcars$mpg,y=mtcars$qsec,xlab="Lmao",ylab="Ayyy")
nxt()
?boxplot
boxplot(formula=mpg~cyl,data=mtcars)
## looks sexier than typical scatterplot
hist(mtcars$mpg)
